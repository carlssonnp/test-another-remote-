What does the following function do? What would be a good name for it?

* **it keeps the values on the original function run**

Modify delay_by() so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called g <- delay_by(1, f); g(); Sys.sleep(2); g() there shouldn’t be an extra delay.

delay_by <- function(delay, f) {
  force(f)
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}

Write wait_until() which delays execution until a specific time

wait_until <- function(time_to_run, f) {
	wait <- time_to_run - Sys.time()
	force(f)
  	function(...) {
  		if wait > 0 {
  			Sys.sleep(wait)
  			f(...)
  		}
    }
  }
}

There are three places we could have added a memoise call: why did we choose the one we did?

download <- memoise(dot_every(10, delay_by(1, download_file)))
download <- dot_every(10, memoise(delay_by(1, download_file)))
download <- dot_every(10, delay_by(1, memoise(download_file)))

* We want to cache the results of delay_by() to be able to know when to dot_every()

Why is the remember() function inefficient? How could you implement it in more efficient way?
* It's inefficient because it has to append to a list it has to remember, which is generally inefficient. Could improve it using unlist() or lapply()

Why does the following code, from stackoverflow, not do what you expect?
* **this bug has been resolved, but the idea is that R has lazy evaluation, so in this case we would want to force evaluation of a and b**

Create a negative() FO that flips the sign of the output of the function to which it is applied.
* negative <- function(f) {
  force(f)
  function(...) {-f(...)}
}

The evaluate package makes it easy to capture all the outputs (results, text, messages, warnings, errors, and plots) from an expression. Create a function like capture_it() that also captures the warnings and errors generated by a function.

capture_it <- function(f) {
  force(f)
  function(...) {
    evaluate(f(...))
  }
}


Create a FO that tracks files created or deleted in the working directory (Hint: use dir() and setdiff().) What other global effects of functions might you want to track?

track_dir <- function(f) {
	force(f)
	function(..) {
	old <- dir()
	f(...)
	new <- dir()
	change <- setdidff(old, new)
}
}

Our previous download() function only downloads a single file. How can you use partial() and lapply() to create a function that downloads multiple files at once? What are the pros and cons of using partial() vs. writing a function by hand?

download_file <- function(url, ...) {
  download.file(url)
}

download_file_compact <- partial(download.file)
lapply(partial(download_file_compact))

* **while it creates a function similar to the anonymous func, it's hard to tell how it works with lazy evaluation.**


Write FOs that convert a function to return a matrix instead of a data frame, or a data frame instead of a matrix
* as_data_frame <- function(f){
  force(f)
  function(...) {as.data.frame(f(...))}
}

You’ve seen five functions that modify a function to change its output from one form to another. What are they? Draw a table of the various combinations of types of outputs: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.

* negate returns the opposite of the logical value returned by a func
* pryr::failswith() turns the error output of a function into a default value
* capture_it returns the text that the fun printed
* time_it returns how long a fun took to run

Look at all the examples of using an anonymous function to partially apply a function in this and the previous chapter. Replace the anonymous function with partial(). What do you think of the result? Is it easier or harder to read?

* f <- function(a) g(a, b = 1) becomes f <- partial(g, b = 1) and easier to read

Implement your own version of compose() using Reduce and %o%.

compose <- function(f1, f2) {
	force(f1); force(f2)
	function(...) {
		f1(f2)
}

compose_many <-function(...) {
	Reduce(compose, ...)
}
}

Extend and() and or() to deal with any number of input functions. Can you do it with Reduce()? Can you keep them lazy (e.g., for and(), the function returns once it sees the first FALSE)?

and2 <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) && f2(...)
  }
}

and3 <- <-function(...) {
	Reduce(and2, ...)
}

Implement the xor() binary operator. Implement it using the existing xor() function. Implement it as a combination of and() and or(). What are the advantages and disadvantages of each approach? Also think about what you’ll call the resulting function to avoid a clash with the existing xor() function, and how you might change the names of and(), not(), and or() to keep them consistent.

xor2 <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) && !f2(...) || !f1(...) && f2(...)
  }
}

Above, we implemented boolean algebra for functions that return a logical function. Implement elementary algebra (plus(), minus(), multiply(), divide(), exponentiate(), log()) for functions that return numeric vectors.

plus <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) + f2(...)
  }
}