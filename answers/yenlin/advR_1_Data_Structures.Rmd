
####Vectors

#####1. What are the six types of atomic vector? How does a list differ from an atomic vector?

Ans: The six types of atomic vectors are : logical, integer, double, character, complex, and raw. List elements don't necessarily have the same type, whereas atomic vector elements have to.


#####2. What makes is.vector() and is.numeric() fundamentally different to is.list() and is.character()?

Ans: `is.vector` and `is.numeric` are general tests, not specific tests for types. However, `is.list` and `is.character` test for exact types.


#####3. Test your knowledge of vector coercion rules by predicting the output of the following uses of c(): 

Ans:

`c(1, FALSE)`:  numeric 1 0

`c("a", 1)`: character "a" "FALSE"

`c(list(1), "a")`: list 1 "a"

`c(TRUE, 1L)`: numeric 1 1


#####4. Why do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?

Ans: `as.vector()` will not coerce to an atomic vector, just leave as a list, while `unlist()` uses the same coercion rules as `c()`.


#####5. Why is 1 == "1" true? Why is -1 < FALSE true? Why is "one" < 2 false?

Ans: Because the logic of 1 equals 1 is true. 
The logic of -1 < FALSE is -1 < 0, which is true. 
"one" < 2 is false because R coerces 2 to "2", and "2" is alphabetically before "one".


#####6. Why is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)

Ans: In the example, using c with a character NA coerces everyting to character. Logical is a the "bottom" of the heirarchy, so it can't drag anything else up to its level.


